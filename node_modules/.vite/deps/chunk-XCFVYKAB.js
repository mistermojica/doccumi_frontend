import {
  createChainedFunction_default
} from "./chunk-MFAHH25P.js";
import {
  require_classnames
} from "./chunk-LV2RRUNR.js";
import {
  ENTERED,
  ENTERING,
  EXITED,
  EXITING,
  Transition_default
} from "./chunk-EYZFQRPM.js";
import {
  _objectWithoutPropertiesLoose
} from "./chunk-3SXSN64F.js";
import {
  _extends
} from "./chunk-4Q5LKAZL.js";
import {
  require_react
} from "./chunk-GLGE2QFG.js";
import {
  __toESM,
  init_buffer,
  init_virtual_process_polyfill
} from "./chunk-ZVHMAZMO.js";

// node_modules/react-bootstrap/esm/Collapse.js
init_virtual_process_polyfill();
init_buffer();
var import_classnames = __toESM(require_classnames());

// node_modules/dom-helpers/esm/css.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/dom-helpers/esm/getComputedStyle.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/dom-helpers/esm/ownerWindow.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/dom-helpers/esm/ownerDocument.js
init_virtual_process_polyfill();
init_buffer();
function ownerDocument(node) {
  return node && node.ownerDocument || document;
}

// node_modules/dom-helpers/esm/ownerWindow.js
function ownerWindow(node) {
  var doc = ownerDocument(node);
  return doc && doc.defaultView || window;
}

// node_modules/dom-helpers/esm/getComputedStyle.js
function getComputedStyle(node, psuedoElement) {
  return ownerWindow(node).getComputedStyle(node, psuedoElement);
}

// node_modules/dom-helpers/esm/hyphenateStyle.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/dom-helpers/esm/hyphenate.js
init_virtual_process_polyfill();
init_buffer();
var rUpper = /([A-Z])/g;
function hyphenate(string) {
  return string.replace(rUpper, "-$1").toLowerCase();
}

// node_modules/dom-helpers/esm/hyphenateStyle.js
var msPattern = /^ms-/;
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, "-ms-");
}

// node_modules/dom-helpers/esm/isTransform.js
init_virtual_process_polyfill();
init_buffer();
var supportedTransforms = /^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i;
function isTransform(value) {
  return !!(value && supportedTransforms.test(value));
}

// node_modules/dom-helpers/esm/css.js
function style(node, property) {
  var css = "";
  var transforms = "";
  if (typeof property === "string") {
    return node.style.getPropertyValue(hyphenateStyleName(property)) || getComputedStyle(node).getPropertyValue(hyphenateStyleName(property));
  }
  Object.keys(property).forEach(function(key) {
    var value = property[key];
    if (!value && value !== 0) {
      node.style.removeProperty(hyphenateStyleName(key));
    } else if (isTransform(key)) {
      transforms += key + "(" + value + ") ";
    } else {
      css += hyphenateStyleName(key) + ": " + value + ";";
    }
  });
  if (transforms) {
    css += "transform: " + transforms + ";";
  }
  node.style.cssText += ";" + css;
}
var css_default = style;

// node_modules/react-bootstrap/esm/Collapse.js
var import_react = __toESM(require_react());

// node_modules/react-bootstrap/esm/transitionEndListener.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/dom-helpers/esm/transitionEnd.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/dom-helpers/esm/listen.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/dom-helpers/esm/addEventListener.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/dom-helpers/esm/canUseDOM.js
init_virtual_process_polyfill();
init_buffer();
var canUseDOM_default = !!(typeof window !== "undefined" && window.document && window.document.createElement);

// node_modules/dom-helpers/esm/addEventListener.js
var optionsSupported = false;
var onceSupported = false;
try {
  options = {
    get passive() {
      return optionsSupported = true;
    },
    get once() {
      return onceSupported = optionsSupported = true;
    }
  };
  if (canUseDOM_default) {
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, true);
  }
} catch (e) {
}
var options;
function addEventListener(node, eventName, handler, options) {
  if (options && typeof options !== "boolean" && !onceSupported) {
    var once = options.once, capture = options.capture;
    var wrappedHandler = handler;
    if (!onceSupported && once) {
      wrappedHandler = handler.__once || function onceHandler(event) {
        this.removeEventListener(eventName, onceHandler, capture);
        handler.call(this, event);
      };
      handler.__once = wrappedHandler;
    }
    node.addEventListener(eventName, wrappedHandler, optionsSupported ? options : capture);
  }
  node.addEventListener(eventName, handler, options);
}
var addEventListener_default = addEventListener;

// node_modules/dom-helpers/esm/removeEventListener.js
init_virtual_process_polyfill();
init_buffer();
function removeEventListener(node, eventName, handler, options) {
  var capture = options && typeof options !== "boolean" ? options.capture : options;
  node.removeEventListener(eventName, handler, capture);
  if (handler.__once) {
    node.removeEventListener(eventName, handler.__once, capture);
  }
}
var removeEventListener_default = removeEventListener;

// node_modules/dom-helpers/esm/listen.js
function listen(node, eventName, handler, options) {
  addEventListener_default(node, eventName, handler, options);
  return function() {
    removeEventListener_default(node, eventName, handler, options);
  };
}
var listen_default = listen;

// node_modules/dom-helpers/esm/triggerEvent.js
init_virtual_process_polyfill();
init_buffer();
function triggerEvent(node, eventName, bubbles, cancelable) {
  if (bubbles === void 0) {
    bubbles = false;
  }
  if (cancelable === void 0) {
    cancelable = true;
  }
  if (node) {
    var event = document.createEvent("HTMLEvents");
    event.initEvent(eventName, bubbles, cancelable);
    node.dispatchEvent(event);
  }
}

// node_modules/dom-helpers/esm/transitionEnd.js
function parseDuration(node) {
  var str = css_default(node, "transitionDuration") || "";
  var mult = str.indexOf("ms") === -1 ? 1e3 : 1;
  return parseFloat(str) * mult;
}
function emulateTransitionEnd(element, duration, padding) {
  if (padding === void 0) {
    padding = 5;
  }
  var called = false;
  var handle = setTimeout(function() {
    if (!called)
      triggerEvent(element, "transitionend", true);
  }, duration + padding);
  var remove = listen_default(element, "transitionend", function() {
    called = true;
  }, {
    once: true
  });
  return function() {
    clearTimeout(handle);
    remove();
  };
}
function transitionEnd(element, handler, duration, padding) {
  if (duration == null)
    duration = parseDuration(element) || 0;
  var removeEmulate = emulateTransitionEnd(element, duration, padding);
  var remove = listen_default(element, "transitionend", handler);
  return function() {
    removeEmulate();
    remove();
  };
}

// node_modules/react-bootstrap/esm/transitionEndListener.js
function parseDuration2(node, property) {
  var str = css_default(node, property) || "";
  var mult = str.indexOf("ms") === -1 ? 1e3 : 1;
  return parseFloat(str) * mult;
}
function transitionEndListener(element, handler) {
  var duration = parseDuration2(element, "transitionDuration");
  var delay = parseDuration2(element, "transitionDelay");
  var remove = transitionEnd(element, function(e) {
    if (e.target === element) {
      remove();
      handler(e);
    }
  }, duration + delay);
}

// node_modules/react-bootstrap/esm/triggerBrowserReflow.js
init_virtual_process_polyfill();
init_buffer();
function triggerBrowserReflow(node) {
  node.offsetHeight;
}

// node_modules/react-bootstrap/esm/Collapse.js
var _excluded = ["onEnter", "onEntering", "onEntered", "onExit", "onExiting", "className", "children", "dimension", "getDimensionValue"];
var _collapseStyles;
var MARGINS = {
  height: ["marginTop", "marginBottom"],
  width: ["marginLeft", "marginRight"]
};
function getDefaultDimensionValue(dimension, elem) {
  var offset = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
  var value = elem[offset];
  var margins = MARGINS[dimension];
  return value + parseInt(css_default(elem, margins[0]), 10) + parseInt(css_default(elem, margins[1]), 10);
}
var collapseStyles = (_collapseStyles = {}, _collapseStyles[EXITED] = "collapse", _collapseStyles[EXITING] = "collapsing", _collapseStyles[ENTERING] = "collapsing", _collapseStyles[ENTERED] = "collapse show", _collapseStyles);
var defaultProps = {
  in: false,
  timeout: 300,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  getDimensionValue: getDefaultDimensionValue
};
var Collapse = import_react.default.forwardRef(function(_ref, ref) {
  var onEnter = _ref.onEnter, onEntering = _ref.onEntering, onEntered = _ref.onEntered, onExit = _ref.onExit, onExiting = _ref.onExiting, className = _ref.className, children = _ref.children, _ref$dimension = _ref.dimension, dimension = _ref$dimension === void 0 ? "height" : _ref$dimension, _ref$getDimensionValu = _ref.getDimensionValue, getDimensionValue = _ref$getDimensionValu === void 0 ? getDefaultDimensionValue : _ref$getDimensionValu, props = _objectWithoutPropertiesLoose(_ref, _excluded);
  var computedDimension = typeof dimension === "function" ? dimension() : dimension;
  var handleEnter = (0, import_react.useMemo)(function() {
    return createChainedFunction_default(function(elem) {
      elem.style[computedDimension] = "0";
    }, onEnter);
  }, [computedDimension, onEnter]);
  var handleEntering = (0, import_react.useMemo)(function() {
    return createChainedFunction_default(function(elem) {
      var scroll = "scroll" + computedDimension[0].toUpperCase() + computedDimension.slice(1);
      elem.style[computedDimension] = elem[scroll] + "px";
    }, onEntering);
  }, [computedDimension, onEntering]);
  var handleEntered = (0, import_react.useMemo)(function() {
    return createChainedFunction_default(function(elem) {
      elem.style[computedDimension] = null;
    }, onEntered);
  }, [computedDimension, onEntered]);
  var handleExit = (0, import_react.useMemo)(function() {
    return createChainedFunction_default(function(elem) {
      elem.style[computedDimension] = getDimensionValue(computedDimension, elem) + "px";
      triggerBrowserReflow(elem);
    }, onExit);
  }, [onExit, getDimensionValue, computedDimension]);
  var handleExiting = (0, import_react.useMemo)(function() {
    return createChainedFunction_default(function(elem) {
      elem.style[computedDimension] = null;
    }, onExiting);
  }, [computedDimension, onExiting]);
  return import_react.default.createElement(
    Transition_default,
    _extends({
      ref,
      addEndListener: transitionEndListener
    }, props, {
      "aria-expanded": props.role ? props.in : null,
      onEnter: handleEnter,
      onEntering: handleEntering,
      onEntered: handleEntered,
      onExit: handleExit,
      onExiting: handleExiting
    }),
    function(state, innerProps) {
      return import_react.default.cloneElement(children, _extends({}, innerProps, {
        className: (0, import_classnames.default)(className, children.props.className, collapseStyles[state], computedDimension === "width" && "width")
      }));
    }
  );
});
Collapse.defaultProps = defaultProps;
var Collapse_default = Collapse;

export {
  ownerDocument,
  css_default,
  canUseDOM_default,
  addEventListener_default,
  removeEventListener_default,
  listen_default,
  transitionEnd,
  transitionEndListener,
  triggerBrowserReflow,
  Collapse_default
};
//# sourceMappingURL=chunk-XCFVYKAB.js.map
